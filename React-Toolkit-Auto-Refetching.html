<!DOCTYPE html>
<html>

<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>짐박스 CRM에서 Auto-Refetching 구현하기</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/tech-blog/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/tech-blog/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/tech-blog/assets/built/syntax.css" />
    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>
        .hljs {
            background: none;
        }
    </style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->

    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description"
    content="" />
<link rel="shortcut icon" href="/tech-blog/assets/images/supplies-logo-black.png" type="image/png" />
<link rel="canonical"
    href="/tech-blog/React-Toolkit-Auto-Refetching" />
<meta name="referrer" content="no-referrer-when-downgrade" />


<!--title below is coming from _includes/dynamic_title-->
<meta property="og:site_name" content="Supplies Tech Blog" />
<meta property="og:type" content="website" />
<meta property="og:title"
    content="짐박스 CRM에서 Auto-Refetching 구현하기" />
<meta property="og:description"
    content="짐박스 CRM에서 Auto-Refetching 구현하기 들어가며 CRM(Customer Relationship Management) 은 고객 관계 관리 프로그램으로 말하며, 짐박스에 대입하여 말하자면 “헬스장을 다니고 있는 회원의 데이터 관리 프로그램” 으로 설명할 수 있습니다. CRM의 목적은 회원님이 어떤 상품을 결제했고, 이를 언제 갱신하며, 필요한 특정 행동들을 취하는 것이 그 목적이라 할 수 있겠습니다. 뭐가 문제야? 초기" />
<meta property="og:url"
    content="/tech-blog/React-Toolkit-Auto-Refetching" />
<meta property="og:image"
    content="/tech-blog/assets/images/React-Toolkit-Auto-Refetching/cover.png" />
<meta property="article:publisher" content="https://www.facebook.com/" />
<meta property="article:author" content="https://www.facebook.com/" />
<meta property="article:published_time"
    content="2022-08-22T00:15:01+00:00" />
<meta property="article:modified_time"
    content="2022-08-22T00:15:01+00:00" />

<!-- <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="짐박스 CRM에서 Auto-Refetching 구현하기" />
    <meta name="twitter:description" content="짐박스 CRM에서 Auto-Refetching 구현하기 들어가며 CRM(Customer Relationship Management) 은 고객 관계 관리 프로그램으로 말하며, 짐박스에 대입하여 말하자면 “헬스장을 다니고 있는 회원의 데이터 관리 프로그램” 으로 설명할 수 있습니다. CRM의 목적은 회원님이 어떤 상품을 결제했고, 이를 언제 갱신하며, 필요한 특정 행동들을 취하는 것이 그 목적이라 할 수 있겠습니다. 뭐가 문제야? 초기" />
    <meta name="twitter:url" content="/tech-blog/" />
    <meta name="twitter:image" content="/tech-blog/assets/images/React-Toolkit-Auto-Refetching/cover.png" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="Supplies Tech Blog" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" /> -->
<meta property="og:image:width" content="1400" />
<meta property="og:image:height" content="933" />

<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "Supplies Tech Blog",
        "logo": "/tech-blog/"
    },
    "url": "/tech-blog/React-Toolkit-Auto-Refetching",
    "image": {
        "@type": "ImageObject",
        "url": "/tech-blog/assets/images/React-Toolkit-Auto-Refetching/cover.png",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "/tech-blog/React-Toolkit-Auto-Refetching"
    },
    "description": "짐박스 CRM에서 Auto-Refetching 구현하기 들어가며 CRM(Customer Relationship Management) 은 고객 관계 관리 프로그램으로 말하며, 짐박스에 대입하여 말하자면 “헬스장을 다니고 있는 회원의 데이터 관리 프로그램” 으로 설명할 수 있습니다. CRM의 목적은 회원님이 어떤 상품을 결제했고, 이를 언제 갱신하며, 필요한 특정 행동들을 취하는 것이 그 목적이라 할 수 있겠습니다. 뭐가 문제야? 초기"
}
    </script>

<!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

<meta name="generator" content="Jekyll 3.6.2" />
<link rel="alternate" type="application/rss+xml"
    title="짐박스 CRM에서 Auto-Refetching 구현하기"
    href="/tech-blog/feed.xml" />

</head>

<body
    class="post-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->

<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="/tech-blog/">Supplies Tech Blog</a>
            
        
        
            <ul class="nav" role="menu">
    <!-- <li class="nav-home" role="menuitem"><a href="/tech-blog/">Home</a></li> -->
    <!-- <li class="nav-about" role="menuitem"><a href="/tech-blog/about/">About</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="/tech-blog/tag/getting-started/">Getting Started</a></li>
    <li class="nav-try-ghost" role="menuitem"><a href="https://ghost.org">Try Ghost</a></li> -->
</ul>
        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  post ">

            <header class="post-full-header">
                <section class="post-full-meta">
                    <time class="post-full-meta-date" datetime="22 August 2022">22 August 2022</time>
                    
                </section>
                <h1 class="post-full-title">짐박스 CRM에서 Auto-Refetching 구현하기</h1>
            </header>

            
            <figure class="post-full-image" style="background-image: url(/tech-blog/assets/images/React-Toolkit-Auto-Refetching/cover.png)">
            </figure>
            

            <section class="post-full-content">
                <div class="kg-card-markdown">
                    <h1 id="짐박스-crm에서-auto-refetching-구현하기">짐박스 CRM에서 Auto-Refetching 구현하기</h1>

<h2 id="들어가며">들어가며</h2>

<p><strong>CRM(Customer Relationship Management)</strong> 은 고객 관계 관리 프로그램으로 말하며, 짐박스에 대입하여 말하자면 “헬스장을 다니고 있는 회원의 데이터 관리 프로그램” 으로 설명할 수 있습니다.</p>

<p>CRM의 목적은 회원님이 어떤 상품을 결제했고, 이를 언제 갱신하며, 필요한 특정 행동들을 취하는 것이 그 목적이라 할 수 있겠습니다.</p>

<h2 id="뭐가-문제야">뭐가 문제야?</h2>

<p>초기 짐박스 CRM 은 Redux 를 사용하여 상태를 관리하고 있었습니다. 하지만 시간이 갈수록 CRM의 덩치가 커지면서 여러가지 기능들이 붙기 시작했습니다.</p>

<p>그러다 보니 actionType을 정의하고, 그 함수를 정의하고 Reducer를 정의하여 1개의 액션을 생성하는 방식은 점차 비효율적으로 다가왔고, 이에따라 Redux-Toolkit 패키지 중 RTK Query를 도입했습니다.</p>

<blockquote>
  <p><strong>우리가 왜 RTK Query를 도입했는가? 3줄로 요약하면,</strong></p>
</blockquote>

<ul>
  <li>CRM 특성상 여러가지 액션이 많은데, 이를 Redux를 통해 일일히 작성하는 것은 무리</li>
  <li>Hook 을 제공하여 데이터를 Fetching, Catching 할 때의 State를 쉽게 사용할 수 있음</li>
  <li>Auto-ReFetching 의 효율성</li>
</ul>

<h2 id="query--mutation-그리고-auto-refetching">Query &amp; Mutation, 그리고 Auto-Refetching</h2>

<p>지금부터 RTK Query의 Query와 Mutation 을 간단하게 알아보고 <strong>이를 자동으로 Refetching 하는 구조에 대해 이야기해보고자 합니다.</strong> Query와 Mutation 에 대한 자세한 설명은 <a href="https://redux-toolkit.js.org/rtk-query/usage/queries">공식</a> <a href="https://redux-toolkit.js.org/rtk-query/usage/mutations">문서</a>에서 확인 가능합니다.</p>

<h3 id="query">Query</h3>

<p>일반적으로 Redux에서 데이터(상태)를 불러오는 과정을 설명하면</p>

<ol>
  <li>상태를 관리하는 리덕스 스토어에서 Reducer 를 호출하고 그 리턴 값을 초기 상태로 저장하고</li>
  <li>UI가 처음 렌더링 될 때, 이 UI를 렌더링하는 컴포넌트는 위 리덕스 스토어의 상태에 접근하며</li>
  <li>이 상태를 렌더링에 활용합니다.</li>
</ol>

<p>이 데이터의 상태를 감지하기 위해서는 여러번의 useSelector, useEffect 를 사용해야합니다.</p>

<p><strong>하지만 RTK Query 에서는 useQuery Hook 을 제공하여, 이 모든 것을 하나의 Hook으로 대체합니다.</strong></p>

<p>또한 해당 Hook 에는 Query의 Loading, Fetch, Error 의 상태를 알 수 있는 프로퍼티들이 존재하여, UI의 가변성을 높여줍니다.</p>

<p>데이터가 Loading 상태일 때는 스피너를 보여주고, 데이터를 성공적으로 받아오면(Success) UI, 에러가 발생하면(Error) 에러 메세지를 보여주는 식으로 말이죠.</p>

<h3 id="mutation">Mutation</h3>

<p><strong>Redux에서 데이터를 업데이트하는 방식도 RTKQ가 제공하는 Mutation Hook으로 단순화 할 수 있습니다.</strong></p>

<p>일반적으로 Redux 에서는 아래와 같이 데이터를 업데이트합니다.</p>

<ol>
  <li>유저가 UI 를 통해 이벤트 핸들러를 작동시키면</li>
  <li>Dispatch 가 일어나서 액션을 일으키고</li>
  <li>스토어에서는 액션 타입과 payload 값을 받고</li>
  <li>이전 상태와 들어온 액션으로 리듀서 함수를 실행하고, 함수의 리턴 값을 새로운 상태로 변경한다.</li>
  <li>상태값이 변화함에 따라 해당 스토어를 구독 중인 UI들은 새로운 상태 값으로 렌더링 된다.</li>
</ol>

<p>이를 위해서는 여러가지 액션 타입을 정의해주고, 액션 함수를 생성해야했으며 이에 따라 보일러플레이트 코드를 생성해줘야만 했습니다.</p>

<p>Mutation Hook 은 액션 타입, 액션 함수 생성 등 여러가지 불필요한 코드를 작성하지 않고도, 상태를 업데이트할 수 있게 도와줍니다. <strong>또한 Mutation은 Trigger 함수를 파라미터로 제공하며, 해당 Trigger 함수를 통해 상태를 업데이트 할 수 있습니다.</strong></p>

<p>useQuery Hook 과 동일하게, 상태를 알 수 있는 여러 프로퍼티를 제공하여 UI의 가변성을 높여줍니다.</p>

<h3 id="auto-refetching">Auto-Refetching</h3>

<p>useQuery, useMutation 을 통해 데이터를 가져오고 수정하더라도 이를 실시간으로 확인할 수 없다면 사용하는 유저 입장에서는 혼돈이 올 수 밖에 없습니다. 특정 버튼을 눌러 새로고침을 하거나, 아예 페이지를 새로고침하는 방법이 있을 수 있긴 한데 이는 UX 측면에서 상당히 불필요한 행동입니다.</p>

<p><strong>RTKQ 에서는 불필요한 행동을 방지하고, 유저에게 가장 최근의 데이터를 보여줄 수 있는 Auto-Refetching 기능을 구현할 수 있습니다.</strong></p>

<ol>
  <li>
    <p>☝🏻 RTKQ 에서는 Query 와 Mutation 의 연관관계를 정의함으로써 자동으로 데이터를 Refetching 할 수 있는데, <strong>이는 Tag 를 사용하여 가능합니다.</strong></p>
  </li>
  <li>
    <p>🤞🏻 <strong>이때 Tag 는 Automated Re-fetching 을 위한 고유한 값입니다</strong>. Label 이라고 생각하면 편하며, Query 가 제공하고 Mutation 이 Re-fetching을 할지 안할지 결정합니다.</p>
  </li>
</ol>

<p>우선 createApi 내부에서 <strong><code class="language-plaintext highlighter-rouge">tagTypes</code></strong> 를 선언합니다.</p>

<p><strong><code class="language-plaintext highlighter-rouge">tagTypes</code></strong>는 Array 형식으로 선언하며 각 항목은 String 값으로 선언되어야합니다. 보통 Tag는 Query와 Mutation 의 관계를 명확하게 이해할 수 있는 값으로 선언합니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">createApi</span><span class="p">,</span> <span class="nx">fetchBaseQuery</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">@reduxjs/toolkit/query</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">api</span> <span class="o">=</span> <span class="nx">createApi</span><span class="p">({</span>
  <span class="na">baseQuery</span><span class="p">:</span> <span class="nx">fetchBaseQuery</span><span class="p">({</span>
    <span class="na">baseUrl</span><span class="p">:</span> <span class="dl">"</span><span class="s2">/</span><span class="dl">"</span><span class="p">,</span>
  <span class="p">}),</span>
  <span class="na">tagTypes</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">Post</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">User</span><span class="dl">"</span><span class="p">],</span> <span class="c1">// createApi 파라미터에서 tagTypes 선언</span>
  <span class="na">endpoints</span><span class="p">:</span> <span class="p">(</span><span class="nx">build</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span>
    <span class="na">getPosts</span><span class="p">:</span> <span class="nx">build</span><span class="p">.</span><span class="nx">query</span><span class="p">({</span>
      <span class="na">query</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="dl">"</span><span class="s2">/posts</span><span class="dl">"</span><span class="p">,</span>
    <span class="p">}),</span>
    <span class="na">getUsers</span><span class="p">:</span> <span class="nx">build</span><span class="p">.</span><span class="nx">query</span><span class="p">({</span>
      <span class="na">query</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="dl">"</span><span class="s2">/users</span><span class="dl">"</span><span class="p">,</span>
    <span class="p">}),</span>
    <span class="na">addPost</span><span class="p">:</span> <span class="nx">build</span><span class="p">.</span><span class="nx">mutation</span><span class="p">({</span>
      <span class="na">query</span><span class="p">:</span> <span class="p">(</span><span class="nx">body</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span>
        <span class="na">url</span><span class="p">:</span> <span class="dl">"</span><span class="s2">post</span><span class="dl">"</span><span class="p">,</span>
        <span class="na">method</span><span class="p">:</span> <span class="dl">"</span><span class="s2">POST</span><span class="dl">"</span><span class="p">,</span>
        <span class="nx">body</span><span class="p">,</span>
      <span class="p">}),</span>
    <span class="p">}),</span>
  <span class="p">}),</span>
<span class="p">});</span>
</code></pre></div></div>

<p><strong>그 이후 endpoints 함수에 Tag 값을 부여합니다.</strong></p>

<p>이때 Query는 Tag를 부여하는 <code class="language-plaintext highlighter-rouge">provideTags</code>로, Mutation은 Tag를 Invalidate 하는 <code class="language-plaintext highlighter-rouge">invalidateTags</code>로 부여합니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">createApi</span><span class="p">,</span> <span class="nx">fetchBaseQuery</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">@reduxjs/toolkit/query</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">api</span> <span class="o">=</span> <span class="nx">createApi</span><span class="p">({</span>
  <span class="na">baseQuery</span><span class="p">:</span> <span class="nx">fetchBaseQuery</span><span class="p">({</span>
    <span class="na">baseUrl</span><span class="p">:</span> <span class="dl">"</span><span class="s2">/</span><span class="dl">"</span><span class="p">,</span>
  <span class="p">}),</span>
  <span class="na">tagTypes</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">Post</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">User</span><span class="dl">"</span><span class="p">],</span> <span class="c1">// createApi 파라미터에서 tagTypes 선언</span>
  <span class="na">endpoints</span><span class="p">:</span> <span class="p">(</span><span class="nx">build</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span>
    <span class="na">getPosts</span><span class="p">:</span> <span class="nx">build</span><span class="p">.</span><span class="nx">query</span><span class="p">({</span>
      <span class="na">query</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="dl">"</span><span class="s2">/posts</span><span class="dl">"</span><span class="p">,</span>
      <span class="na">providesTags</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">Post</span><span class="dl">"</span><span class="p">],</span> <span class="c1">// posts를 호출할 때 해당 데이터에 Post Tag 부여</span>
    <span class="p">}),</span>
    <span class="na">getUsers</span><span class="p">:</span> <span class="nx">build</span><span class="p">.</span><span class="nx">query</span><span class="p">({</span>
      <span class="na">query</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="dl">"</span><span class="s2">/users</span><span class="dl">"</span><span class="p">,</span>
      <span class="na">providesTags</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">User</span><span class="dl">"</span><span class="p">],</span> <span class="c1">// users를 호출할 때 해당 데이터에 User Tag 부여</span>
    <span class="p">}),</span>
    <span class="na">addPost</span><span class="p">:</span> <span class="nx">build</span><span class="p">.</span><span class="nx">mutation</span><span class="p">({</span>
      <span class="na">query</span><span class="p">:</span> <span class="p">(</span><span class="nx">body</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span>
        <span class="na">url</span><span class="p">:</span> <span class="dl">"</span><span class="s2">post</span><span class="dl">"</span><span class="p">,</span>
        <span class="na">method</span><span class="p">:</span> <span class="dl">"</span><span class="s2">POST</span><span class="dl">"</span><span class="p">,</span>
        <span class="nx">body</span><span class="p">,</span>
      <span class="p">}),</span>
      <span class="na">invalidateTags</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">Post</span><span class="dl">"</span><span class="p">],</span> <span class="c1">// Post를 추가할 때, "Post" Tag를 갖고 있는 Query를 새로고침함</span>
    <span class="p">}),</span>
  <span class="p">}),</span>
<span class="p">});</span>
</code></pre></div></div>

<p>하지만 이럴 경우, Mutation으로 하나의 값을 변경했을 때 전체 Query를 불러와 성능에 문제를 일으킬 수 있습니다. 이는 <strong>CRM에서 자주 사용하는 Table 형태의 UI에서 나타날 수 있는 이슈입니다.</strong></p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">createApi</span><span class="p">,</span> <span class="nx">fetchBaseQuery</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">@reduxjs/toolkit/query</span><span class="dl">'</span>

<span class="kd">const</span> <span class="nx">api</span> <span class="o">=</span> <span class="nx">createApi</span><span class="p">({</span>
  <span class="na">baseQuery</span><span class="p">:</span> <span class="nx">fetchBaseQuery</span><span class="p">({</span>
    <span class="na">baseUrl</span><span class="p">:</span> <span class="dl">'</span><span class="s1">/</span><span class="dl">'</span><span class="p">,</span>
  <span class="p">}),</span>
  <span class="na">tagTypes</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">Post</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">User</span><span class="dl">'</span><span class="p">],</span> <span class="c1">// createApi 파라미터에서 tagTypes 선언</span>
  <span class="na">endpoints</span><span class="p">:</span> <span class="p">(</span><span class="nx">build</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span>
    <span class="na">getPosts</span><span class="p">:</span> <span class="nx">build</span><span class="p">.</span><span class="nx">query</span><span class="p">({</span>
      <span class="na">query</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="dl">'</span><span class="s1">/posts</span><span class="dl">'</span><span class="p">,</span>
			<span class="na">providesTags</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">Post</span><span class="dl">'</span><span class="p">],</span> <span class="c1">// posts를 호출할 때 해당 데이터에 Post Tag 부여</span>
    <span class="p">}),</span>
    <span class="na">getUsers</span><span class="p">:</span> <span class="nx">build</span><span class="p">.</span><span class="nx">query</span><span class="p">({</span>
      <span class="na">query</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="dl">'</span><span class="s1">/users</span><span class="dl">'</span><span class="p">,</span>
			<span class="na">providesTags</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">User</span><span class="dl">'</span><span class="p">],</span> <span class="c1">// users를 호출할 때 해당 데이터에 User Tag 부여</span>
    <span class="p">}),</span>
    <span class="na">addPost</span><span class="p">:</span> <span class="nx">build</span><span class="p">.</span><span class="nx">mutation</span><span class="p">({</span>
      <span class="na">query</span><span class="p">:</span> <span class="p">(</span><span class="nx">body</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span>
        <span class="na">url</span><span class="p">:</span> <span class="dl">'</span><span class="s1">post</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">method</span><span class="p">:</span> <span class="dl">'</span><span class="s1">POST</span><span class="dl">'</span><span class="p">,</span>
        <span class="nx">body</span><span class="p">,</span>
      <span class="p">}),</span>
			<span class="na">invalidateTags</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">Post</span><span class="dl">'</span><span class="p">],</span> <span class="c1">// Post를 추가할 때, "Post" Tag를 갖고 있는 Query를 새로고침함</span>
    <span class="p">})</span>
    <span class="na">editPost</span><span class="p">:</span> <span class="nx">build</span><span class="p">.</span><span class="nx">mutation</span><span class="p">({</span>
      <span class="na">query</span><span class="p">:</span> <span class="p">(</span><span class="nx">body</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span>
        <span class="na">url</span><span class="p">:</span> <span class="s2">`post/</span><span class="p">${</span><span class="nx">body</span><span class="p">.</span><span class="nx">id</span><span class="p">}</span><span class="s2">`</span><span class="p">,</span>
        <span class="na">method</span><span class="p">:</span> <span class="dl">'</span><span class="s1">POST</span><span class="dl">'</span><span class="p">,</span>
        <span class="nx">body</span><span class="p">,</span>
      <span class="p">}),</span>
			<span class="na">invalidateTags</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">Post</span><span class="dl">'</span><span class="p">],</span>
    <span class="p">}),</span>
  <span class="p">}),</span>
<span class="p">})</span>
</code></pre></div></div>

<p>위 코드에서 getPosts 로 여러개의 Post를 가져온다고 가정해봅시다. 그리고 그 중 하나의 Post를 editPost로 Post의 제목을 수정한다고 하면, 아래와 같은 플로우로 진행이 될 것입니다.</p>

<p><img src="./assets/images/React-Toolkit-Auto-Refetching/Auto-Refetching-Sample.png" alt="Untitled" /></p>

<ol>
  <li>useEditPostMutation이 제공하는 Trigger 함수로 상태를 변경합니다.</li>
  <li>같은 Tag 값을 갖고 있는 useGetPostsQuery 가 Refetching 되어 전체 Post를 내려줍니다.</li>
  <li>UI 에서는 변경된 제목을 확인할 수 있습니다.</li>
</ol>

<p>이때 변경된 Post 값은 1개 인데, 다른 Post 들도 Refetching 되는 이슈가 발생할 수 있습니다. 이때 Query 가 호출하는 데이터에 각각 다른 값을 부여하여 Mutation으로 변경되는 값만 Refetch를 할 수 있습니다.</p>

<p><strong>이는 Tag 에게 <code class="language-plaintext highlighter-rouge">tagType</code> 외에 ID를 부여하여 해결할 수 있습니다. 방법은 아래와 같습니다.</strong></p>

<p>우선 Query 로 데이터를 호출할 때 <strong><code class="language-plaintext highlighter-rouge">tagType</code>외에 고유 값에 기반하여, <code class="language-plaintext highlighter-rouge">Id</code> 값을 Tag로 부여합니다.</strong></p>

<p><code class="language-plaintext highlighter-rouge">providesTags</code>는 result 파라미터를 갖는데, 이 result 파라미터를 통해 Query로 불러온 데이터를 받고, 그 중 고유한 값을 Tag로 부여할 Id 값으로 선정합니다. (아래 코드에서는 postId)</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">providesTags</span><span class="p">:</span> <span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">error</span><span class="p">,</span> <span class="nx">arg</span><span class="p">)</span> <span class="o">=&gt;</span>
	<span class="nx">result</span> <span class="p">?</span>
		<span class="p">[...</span><span class="nx">result</span><span class="p">.</span><span class="nx">map</span><span class="p">(({</span> <span class="nx">postId</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Post</span><span class="dl">'</span><span class="p">,</span> <span class="na">id</span> <span class="p">:</span> <span class="nx">postId</span> <span class="p">})),</span> <span class="dl">'</span><span class="s1">Post</span><span class="dl">'</span><span class="p">]</span>
<span class="c1">// Array 마지막 값으로 "Post"를 제공함으로, addPost 등 전체 값을 다시 가져와야하는 Mutation이 발생할 때,</span>
<span class="c1">// 해당 Query를 Refetch 할 수 있음</span>
	<span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">Post</span><span class="dl">'</span><span class="p">],</span>
</code></pre></div></div>

<p>마찬가지로 Mutation 에도 Tag에 <code class="language-plaintext highlighter-rouge">Id</code> 값을 부여합니다. <strong>이를 통해 Mutation이 실행되었을 때, 해당 Mutation으로 변경한 값(arg.id 와 postId가 일치한 값)만 다시 Refetching을 할 수 있습니다.</strong></p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">invalidatesTags</span><span class="p">:</span> <span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">error</span><span class="p">,</span> <span class="nx">arg</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Post</span><span class="dl">'</span><span class="p">,</span> <span class="na">id</span><span class="p">:</span> <span class="nx">arg</span><span class="p">.</span><span class="nx">id</span> <span class="p">}],</span>
</code></pre></div></div>

<p>만약 특정 Id 값 외에 다른 Tag 도 Refetching 해야한다고 한다면 아래와 같은 방식으로도 사용이 가능합니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">invalidatesTags</span><span class="p">:</span> <span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">error</span><span class="p">,</span> <span class="nx">arg</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Post</span><span class="dl">'</span><span class="p">,</span> <span class="na">id</span><span class="p">:</span> <span class="nx">arg</span><span class="p">.</span><span class="nx">id</span> <span class="p">},</span> <span class="p">[</span><span class="dl">"</span><span class="s2">User</span><span class="dl">"</span><span class="p">]],</span>
<span class="c1">// 특정 Post 값 외에 User Tag를 갖는 데이터 ReFetching</span>
</code></pre></div></div>

<h2 id="마치며">마치며</h2>

<p>특정 행동을 취하고 이를 통해 데이터 값이 변화함을 유저가 느낄 수 있는 것은 CRM에서 매우 중요합니다. 변화함을 인지하지 못하고 특정 행동을 계속 반복하는 불상사를 방지할 수 있기 때문입니다.</p>

<p>RTK Query 는 데이터의 Fetching, Catching을 간편하게 구현해줄 수 있을 뿐만 아니라 특정 값의 Refetching 을 통해 언제나 데이터를 최신 값으로 유지할 수 있는 장점이 있습니다.</p>

                </div>
            </section>

            <!-- Email subscribe form at the bottom of the page -->
            

            <footer class="post-full-footer">
                <!-- Everything inside the #author tags pulls data from the author -->
                <!-- #author-->
                
                    
                
                    
                
                    
                
                    
                        <section class="author-card">
                            
                                <img class="author-profile-image" src="/tech-blog/assets/images/authors/tony.jpeg" alt="Tony" />
                            
                            <section class="author-card-content">
                                <h4 class="author-card-name"><a href="/tech-blog/author/Tony">Tony</a></h4>
                                
                                    <p>Frontend Developer / PO</p>
                                
                            </section>
                        </section>
                        <div class="post-full-footer-right">
                            <a class="author-card-button" href="/tech-blog/author/Tony">Read More</a>
                        </div>
                    
                
                <!-- /author  -->
            </footer>

            <!-- If you use Disqus comments, just uncomment this block.
            The only thing you need to change is "test-apkdzgmqhj" - which
            should be replaced with your own Disqus site-id. -->
            

        </article>

    </div>
</main>

<!-- Links to Previous/Next posts -->
<aside class="read-next outer">
    <div class="inner">
        <div class="read-next-feed">
            

            <!-- If there's a next post, display it using the same markup included from - partials/post-card.hbs -->
            
                

    <article class="post-card post-template">
        
            <a class="post-card-image-link" href="/tech-blog/azure-face-api">
                <div class="post-card-image" style="background-image: url(/tech-blog/assets/images/azure-face-api/face_api.jpeg)"></div>
            </a>
        
        <div class="post-card-content">
            <a class="post-card-content-link" href="/tech-blog/azure-face-api">
                <header class="post-card-header">
                    

                    <h2 class="post-card-title">Azure Face API 사용기</h2>
                </header>
                <section class="post-card-excerpt">
                    
                        <p>Gymboxx 안면 출입 서비스


</p>
                    
                </section>
            </a>
            <footer class="post-card-meta">
                
                    
                        
                        <img class="author-profile-image" src="/tech-blog/assets/images/authors/sue.jpeg" alt="Sue" />
                        
                        <span class="post-card-author">
                            <a href="/tech-blog/author/Sue/">Sue</a>
                        </span>
                    
                
                    
                
                    
                
                    
                
                <span class="reading-time">
                    
                    
                      4 min read
                    
                </span>
            </footer>
        </div>
    </article>

            

            <!-- If there's a previous post, display it using the same markup included from - partials/post-card.hbs -->
            
                

    <article class="post-card post-template">
        
            <a class="post-card-image-link" href="/tech-blog/deep-dive-into-react-function-component">
                <div class="post-card-image" style="background-image: url(/tech-blog/assets/images/react-function-component/function-component-sample.png)"></div>
            </a>
        
        <div class="post-card-content">
            <a class="post-card-content-link" href="/tech-blog/deep-dive-into-react-function-component">
                <header class="post-card-header">
                    

                    <h2 class="post-card-title">React function component</h2>
                </header>
                <section class="post-card-excerpt">
                    
                        <p>Deep dive into React Function Components

</p>
                    
                </section>
            </a>
            <footer class="post-card-meta">
                
                    
                
                    
                
                    
                
                    
                
                <span class="reading-time">
                    
                    
                      3 min read
                    
                </span>
            </footer>
        </div>
    </article>

            

        </div>
    </div>
</aside>

<!-- Floating header which appears on-scroll, included from includes/floating-header.hbs -->
<div class="floating-header">
    <div class="floating-header-logo">
        <a href="/tech-blog/">
            
            <img src="/tech-blog/assets/images/supplies-logo-black.png" alt="Supplies Tech Blog icon" />
            
            <span>Supplies Tech Blog</span>
        </a>
    </div>
    <span class="floating-header-divider">&mdash;</span>
    <div class="floating-header-title">짐박스 CRM에서 Auto-Refetching 구현하기</div>
    <!-- <div class="floating-header-share">
        <div class="floating-header-share-label">Share this <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <path d="M7.5 15.5V4a1.5 1.5 0 1 1 3 0v4.5h2a1 1 0 0 1 1 1h2a1 1 0 0 1 1 1H18a1.5 1.5 0 0 1 1.5 1.5v3.099c0 .929-.13 1.854-.385 2.748L17.5 23.5h-9c-1.5-2-5.417-8.673-5.417-8.673a1.2 1.2 0 0 1 1.76-1.605L7.5 15.5zm6-6v2m-3-3.5v3.5m6-1v2"/>
</svg>
</div>
        <a class="floating-header-share-tw" href="https://twitter.com/share?text=%EC%A7%90%EB%B0%95%EC%8A%A4+CRM%EC%97%90%EC%84%9C+Auto-Refetching+%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0&amp;url=https://suppliesfitness.github.io/tech-blog/React-Toolkit-Auto-Refetching"
            onclick="window.open(this.href, 'share-twitter', 'width=550,height=235');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M30.063 7.313c-.813 1.125-1.75 2.125-2.875 2.938v.75c0 1.563-.188 3.125-.688 4.625a15.088 15.088 0 0 1-2.063 4.438c-.875 1.438-2 2.688-3.25 3.813a15.015 15.015 0 0 1-4.625 2.563c-1.813.688-3.75 1-5.75 1-3.25 0-6.188-.875-8.875-2.625.438.063.875.125 1.375.125 2.688 0 5.063-.875 7.188-2.5-1.25 0-2.375-.375-3.375-1.125s-1.688-1.688-2.063-2.875c.438.063.813.125 1.125.125.5 0 1-.063 1.5-.25-1.313-.25-2.438-.938-3.313-1.938a5.673 5.673 0 0 1-1.313-3.688v-.063c.813.438 1.688.688 2.625.688a5.228 5.228 0 0 1-1.875-2c-.5-.875-.688-1.813-.688-2.75 0-1.063.25-2.063.75-2.938 1.438 1.75 3.188 3.188 5.25 4.25s4.313 1.688 6.688 1.813a5.579 5.579 0 0 1 1.5-5.438c1.125-1.125 2.5-1.688 4.125-1.688s3.063.625 4.188 1.813a11.48 11.48 0 0 0 3.688-1.375c-.438 1.375-1.313 2.438-2.563 3.188 1.125-.125 2.188-.438 3.313-.875z"/></svg>

        </a>
        <a class="floating-header-share-fb" href="https://www.facebook.com/sharer/sharer.php?u=https://suppliesfitness.github.io/tech-blog/React-Toolkit-Auto-Refetching"
            onclick="window.open(this.href, 'share-facebook','width=580,height=296');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M19 6h5V0h-5c-3.86 0-7 3.14-7 7v3H8v6h4v16h6V16h5l1-6h-6V7c0-.542.458-1 1-1z"/></svg>

        </a>
    </div> -->
    <progress class="progress" value="0">
        <div class="progress-container">
            <span class="progress-bar"></span>
        </div>
    </progress>
</div>

<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->


        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="/tech-blog/">Supplies Tech Blog</a> &copy; 2022</section>
                <!-- <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyllt/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/tech-blog/">Latest Posts</a>
                    
                    
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a> -->
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function () {
            $('pre code').each(function (i, block) {
                hljs.highlightBlock(block);
            });
        });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous">
        </script>
    <script type="text/javascript" src="/tech-blog/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/tech-blog/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-69281367-1', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
    <script>

// NOTE: Scroll performance is poor in Safari
// - this appears to be due to the events firing much more slowly in Safari.
//   Dropping the scroll event and using only a raf loop results in smoother
//   scrolling but continuous processing even when not scrolling
$(document).ready(function () {
    // Start fitVids
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
    // End fitVids

    var progressBar = document.querySelector('progress');
    var header = document.querySelector('.floating-header');
    var title = document.querySelector('.post-full-title');

    var lastScrollY = window.scrollY;
    var lastWindowHeight = window.innerHeight;
    var lastDocumentHeight = $(document).height();
    var ticking = false;

    function onScroll() {
        lastScrollY = window.scrollY;
        requestTick();
    }

    function onResize() {
        lastWindowHeight = window.innerHeight;
        lastDocumentHeight = $(document).height();
        requestTick();
    }

    function requestTick() {
        if (!ticking) {
            requestAnimationFrame(update);
        }
        ticking = true;
    }

    function update() {
        var trigger = title.getBoundingClientRect().top + window.scrollY;
        var triggerOffset = title.offsetHeight + 35;
        var progressMax = lastDocumentHeight - lastWindowHeight;

        // show/hide floating header
        if (lastScrollY >= trigger + triggerOffset) {
            header.classList.add('floating-active');
        } else {
            header.classList.remove('floating-active');
        }

        progressBar.setAttribute('max', progressMax);
        progressBar.setAttribute('value', lastScrollY);

        ticking = false;
    }

    window.addEventListener('scroll', onScroll, {passive: true});
    window.addEventListener('resize', onResize, false);

    update();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>

</html>